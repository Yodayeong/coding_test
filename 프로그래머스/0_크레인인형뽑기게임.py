#게임 화면은 "1 x 1" 크기의 칸들로 이루어진 "N x N" 크기의 정사각 격자이며 위쪽에는 크레인이 있고 오른쪽에는 바구니가 있습니다.
#각 격자 칸에는 다양한 인형이 들어 있으며 인형이 없는 칸은 빈칸입니다. 
#모든 인형은 "1 x 1" 크기의 격자 한 칸을 차지하며 격자의 가장 아래 칸부터 차곡차곡 쌓여 있습니다. 
#게임 사용자는 크레인을 좌우로 움직여서 멈춘 위치에서 가장 위에 있는 인형을 집어 올릴 수 있습니다. 
#집어 올린 인형은 바구니에 쌓이게 되는 데, 이때 바구니의 가장 아래 칸부터 인형이 순서대로 쌓이게 됩니다.
#만약 같은 모양의 인형 두 개가 바구니에 연속해서 쌓이게 되면 두 인형은 터뜨려지면서 바구니에서 사라지게 됩니다.
#크레인 작동 시 인형이 집어지지 않는 경우는 없으나 만약 인형이 없는 곳에서 크레인을 작동시키는 경우에는 아무런 일도 일어나지 않습니다. 
#또한 바구니는 모든 인형이 들어갈 수 있을 만큼 충분히 크다고 가정합니다.

#게임 화면의 격자의 상태가 담긴 2차원 배열 board와 인형을 집기 위해 크레인을 작동시킨 위치가 담긴 배열 moves가 매개변수로 주어질 때, 
#크레인을 모두 작동시킨 후 터트려져 사라진 인형의 개수를 return 하도록 solution 함수를 완성해주세요.

board = [[0,0,0,0,0],[0,0,1,0,3],[0,2,5,0,1],[4,2,4,4,2],[3,5,1,3,1]]
moves = [1,5,3,5,1,2,1,4]

def solution(board, moves):
    stack = []
    #빈 stack을 하나 생성해 줍니다.

    cnt = 0
    #총 인형이 터뜨려 진 횟수를 count 해 줄 변수를 둡니다.
    for move in moves:
        #각각의 moves를 돌면서
        i = 0
        while i != len(board):
            #각 격자 칸의 가장 하단부에 도달하기 전까지
            if board[i][move - 1] != 0:
                #만약 인형이 있으면
                stack.append(board[i][move - 1])
                #그 인형을 바구니에 담아주고
                board[i][move - 1] = 0
                #그 자리는 인형이 사라졌으니, 0으로 채워줍니다.
                break
                #while문도 break해 줍니다.
            else:
                i += 1
                #인형이 없다면 격자의 한 칸 아래로 내려갑니다.

        #인형을 바구니에 담았다면, 바구니의 상태를 체크해줍니다.
        if len(stack) < 2:
            #바구니에 2개 미만, 즉 하나의 인형만 담겨있다면,
            continue
            #고려할 필요가 없습니다.
        else:
            #바구니에 인형이 2개 이상 담겨있는데,
            if stack[-1] == stack[-2]:
                #젤 위의 인형과 한 칸 아래의 인형이 같은 인형이라면
                stack.pop()
                stack.pop()
                #2개의 인형을 터뜨려주고
                cnt += 2
                #count도 2 증가시켜 줍니다.

    return cnt
    #더 이상 움직일 moves가 없다면 cnt를 반환해 줍니다.

print(solution(board, moves))
